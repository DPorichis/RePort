from abc import ABC, abstractmethod
import xml.etree.ElementTree as ET
# from RePort.graybox.lookup import CveLookup
from RePort.graybox.scan import *
from ..utils import Logger
from RePort.blackbox.engines import NmapEngine
from RePort.graybox.lookup import CveLookup
import subprocess
import psycopg2
import tarfile
import threading
import shutil
import signal
import shlex
import time
import glob
import sys
import os
import re

log = Logger("Graybox Monitor")

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
ENGINES_FOLDER = os.path.join(PROJECT_ROOT, "engines")

class EmulationEngines(ABC):
    """
    Base class for emulation engines (like FirmUp, FirmINC or custom tools).
    """
    # Key = user option, value = actual flag for the engine
    flag_mapping = {"default": " "}

    def __init__(self, reportStruct=None, firmware='', ip=''):
        if(reportStruct == None):
            self.reportStruct = GrayBoxScan(firmware=firmware, ip_address='')
            self.emulationProc = None

    @abstractmethod
    def install(self):
        """
        installation process for the given engine
        """
        pass

    @abstractmethod
    def name(self):
        """
        Return the name of the mapping engine (e.g. 'nmap', 'custom_engine')
        """
        pass

    def help(self):
        """
        Return the name of the mapping engine (e.g. 'nmap', 'custom_engine')
        """
        output = f"Engine Name: {self.name()} \nSupported Options:\n"
        for option, flag in self.flag_mapping.items():
            output += f"   {option}: \'{flag}\'\n"
        return output

    @abstractmethod
    def analysis(self, scan_result):
        """
        Analyse the logs created by the check() call.
        """
        pass

    @abstractmethod
    def emulate(self):
        """
        Spawns an interactive emulation instance on the given ip. 
        This emulation needs to be terminated via the terminate() function.
        """
        pass

    @abstractmethod
    def terminate(self):
        """
        Quits interactive emulation opened by emulate()
        """
        pass
    
    @abstractmethod
    def check(self, options):
        """
        Performs a booting emulation and exits afterwards. Used to retrive the filesystem and syscall logs.
        """
        pass

    def find_binaries_by_name(self, process_name, path_to_fs):
        """
        Looks up the process name and associates it with possible binaries.
        """
        matches = []
        for dirpath, _, filenames in os.walk(path_to_fs):
            for filename in filenames:
                if filename == process_name:
                    full_path = os.path.join(dirpath, filename)
                    if os.access(full_path, os.X_OK):
                        matches.append(full_path)
        return matches

    def binary_profiling(self, path, name='', ports=[], cert=10):
        """
        Performs binary analysis on a given target, and returns a CriticalBinary instance with its"
        """
        binary = CriticalBinary(path, name, cert, ports)
        return binary

    def verification(self):
        """
        Performs blackbox verification on the emulated target
        """
        blackbox = NmapEngine(ip=self.reportStruct.ip_address)        
        blackbox.scan(self.reportStruct.ip_address, "advanced", self.reportStruct.port_activity.ports_used)
        for port in blackbox.reportStruct.ports.keys():
            if blackbox.reportStruct.ports[port][0]["state"] == "open" and port in self.reportStruct.port_activity.ports_used:
                if port in self.reportStruct.port_activity.port_history.keys():
                    self.reportStruct.port_activity.port_history[port]["verification"] = blackbox.reportStruct.ports[port][0]
                else:
                    log.message("warn", f"Port {port} was found open, but no logs of it where tracked", "Graybox Verification")
        self.reportStruct.black_verification = blackbox
        return

    @abstractmethod
    def clean_up(self):
        """
        Removes cache files genarated by the emulation engine. This DOES NOT include the reports generated by RePort itself.
        """
        return


def list_all_engines():
    log.output("Available engines:")
    for engine_cls in EmulationEngines.__subclasses__():
        engine = engine_cls()
        log.output(f" - {engine.name()} [modes available: {', '.join(engine.flag_mapping.keys())}]")

def get_engine_by_name(name, firmware=''):
    for engine_cls in EmulationEngines.__subclasses__():
        engine = engine_cls(firmware=firmware)
        if engine.name().lower() == name.lower():
            return engine
    return None

def install_all_engines():
    log.message("info","Installing all emulation engines present", "Graybox Installer")
    for engine_cls in EmulationEngines.__subclasses__():
        engine = engine_cls()
        engine.install()
    CveLookup.install()  # Ensure CVE lookup engine is also installed

# FirmAE

class FirmAE(EmulationEngines):

    PATH_TO_FIRMAE = os.path.join(ENGINES_FOLDER, "FirmAE")
    flag_mapping = {"advanced": "-sV", "default": " "}

    DATABASE_NAME = os.getenv("FIRMAE_DB_NAME", "firmware")
    DATABASE_USR = os.getenv("FIRMAE_DB_USER", "firmadyne")
    DATABASE_PSW = os.getenv("FIRMAE_DB_PSW", "firmadyne")
    
    DATABASE_HOST = os.getenv("FIRMAE_DB_HOST", "localhost")
    DATABASE_PORT = os.getenv("FIRMAE_DB_PORT", "5432")

    def __init__(self, reportStruct=None, firmware='', ip='192.168.0.1'):
        if(reportStruct == None):
            self.reportStruct = GrayBoxScan(firmware=firmware, ip_address=ip)
            self.emulationProc = None


    def install(self):

        # Configuration
        REPO_URL = "https://github.com/George-RG/FirmaInc.git"
        TAG = "v0.0.1"
        CLONE_DIR = os.path.join(ENGINES_FOLDER, "FirmAE")

        def run_command(command, cwd=None):
            try:
                subprocess.run(command, cwd=cwd, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                log.message("error", f"Command failed: {e}", "FEMU")                
                sys.exit(1)

        if os.path.isdir(CLONE_DIR):
            log.message("info", f"Repository already exists at {CLONE_DIR}.", "FEMU")
            return
        else:
            os.makedirs(os.path.dirname(CLONE_DIR), exist_ok=True)
            run_command(f"git clone {REPO_URL} {CLONE_DIR}")

        run_command("chmod +x install_apt.sh && ./install_apt.sh", cwd=CLONE_DIR)
        run_command("chmod +x install.sh && ./install.sh", cwd=CLONE_DIR)
        run_command("chmod +x download.sh && ./download.sh", cwd=CLONE_DIR)
        
        log.message("info", "Installation Completed", "FEMU") 

    def name(self):
        return "FirmAE"
    
    def connect_to_db(self):
        try:
            conn = psycopg2.connect(
                dbname=self.DATABASE_NAME,
                user=self.DATABASE_USR,
                password=self.DATABASE_PSW,
                host=self.DATABASE_HOST,
                port=self.DATABASE_PORT
            )
            return conn
        except Exception as e:
            log.message("error", f"Database connection failed: {e}", "FirmAE")
            return None
        
    def analysis(self):

        # Pattern for retriving fork calls:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Clone Flags | 5 - Stack Size
        fork_pattern = r"\[\s*(\d+\.\d+)\]\s+firmadyne:\s+do_fork\[PID:\s*(\d+)\s+\(([^)]+)\)\]:\s+clone_flags:0x([0-9a-fA-F]+),\s+stack_size:0x([0-9a-fA-F]+)"
        
        # Pattern for retriving fork return values:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Child PID
        fork_ret_pattern = r"\[\s*(\d+\.\d+)\]\s+firmadyne:\s+do_fork_ret\[PID:\s*(\d+)\s+\(([^)]+)\)\]\s*=\s*(\d+)"
        
        # Pattern for retriving bind calls:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - fd | 5 - Family | 6 - Port
        bind_pattern = r"\[\s*(\d+\.\d+)\]\s+firmadyne:\s+sys_bind\[PID:\s*(\d+)\s+\(([^)]+)\)\]:\s+fd:(\d+)\s+family:(\d+)\s+port:\s*(\d+)"
        
        # Pattern for retriving bind return values:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Return Code
        bind_ret_pattern = r"\[\s*(\d+\.\d+)\]\s+firmadyne:\s+sys_bind_ret\[PID:\s*(\d+)\s+\(([^)]+)\)\]\s*=\s*(\d+) \[Assigned Port: (\d+)\]"
        
        # Patterns for retriving ipv4 and ipv6 bind calls:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Proto | 5 - Port
        inet4_bind_pattern = r'\[\s*(\d+\.\d+)\]\s+firmadyne:\s+inet_bind\[PID:\s+(\d+)\s+\((.*?)\)\]:\s+proto:(.*?),\s+port:(\d+)'
        inet6_bind_pattern = r'\[\s*(\d+\.\d+)\]\s+firmadyne:\s+inet6_bind\[PID:\s+(\d+)\s+\((.*?)\)\]:\s+proto:(.*?),\s+port:(\d+)'
        
        # Pattern for retriving close calls:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - fd
        close_pattern = r'\[\s*(\d+\.\d+)\]\s+firmadyne:\s+close\[PID:\s*(\d+)\s+\(([^)]+)\)\]:\s+fd:(\d+)'

        # Pattern for retriving exit calls:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Return code
        exit_pattern = r'\[\s*(\d+\.\d+)\]\s+firmadyne:\s+do_exit\[PID:\s*(\d+)\s+\(([^)]+)\)\]:\s+code:(\d+)'

        input_file = self.reportStruct.logs + 'qemu.final.serial.log'

        log.message("info", "Analyzing systemcalls.", "FirmAE")
        with open(input_file, 'r', errors='ignore') as file:
            process_activity = {}

            critical_processes = set()
            reverse_port_mapping = {}

            # Bind cache for each PID
            bind_cache = {}

            for line in file:

                # Search for bind systemcalls
                match = re.search(bind_pattern, line)
                if match:
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    proc_name = match.group(3)
                    fd = int(match.group(4))                    
                    family = int(match.group(5))
                    port = int(match.group(6))
                    if(family == 2 or family == 10):
                        if family == 2:
                            family_string = "IPv4"
                        else:
                            family_string = "IPv6"
                        bind_cache[pid] = {"timestamp":timestamp, 
                                           "pid": pid,
                                           "fd": fd, 
                                           "port": port,
                                           "name": proc_name,
                                           "family": family_string,
                                           "type": "unknown"
                                        }

                # Search for ipv4 bind to retrive port type
                match = re.search(inet4_bind_pattern, line)
                if match:
                    # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Proto | 5 - Port
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    proc_name = match.group(3)
                    proto = match.group(4)                    
                    port = int(match.group(5))
                    if pid in bind_cache.keys():
                        if bind_cache[pid]["port"] == port:
                            if proto == "SOCK_DGRAM":
                                bind_cache[pid]["type"] = "UDP"
                            elif proto == "SOCK_STREAM":
                                bind_cache[pid]["type"] = "TCP"
                            else:
                                bind_cache[pid]["type"] = "Other"

                # Search for ipv6 bind to retrive port type
                match = re.search(inet6_bind_pattern, line)
                if match:
                    # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Proto | 5 - Port
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    proc_name = match.group(3)
                    proto = match.group(4)                    
                    port = int(match.group(5))
                    if pid in bind_cache.keys():
                        if bind_cache[pid]["port"] == port:
                            if proto == "SOCK_DGRAM":
                                bind_cache[pid]["type"] = "UDP"
                            elif proto == "SOCK_STREAM":
                                bind_cache[pid]["type"] = "TCP"
                            else:
                                bind_cache[pid]["type"] = "Other"

                # Search for bind return code to ensure success 
                match = re.search(bind_ret_pattern, line)
                if match:
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    proc_name = match.group(3)
                    ret_code = int(match.group(4))
                    port_assigned = int(match.group(5))
                    if pid in bind_cache.keys():
                        if ret_code == 0:
                            info = bind_cache[pid]
                            random = False
                            if info["port"] == 0 and port_assigned != 0:
                                info["port"] = port_assigned
                                random = True
                            self.reportStruct.port_activity.new_bind(
                                info["timestamp"], 
                                info["pid"], 
                                info["fd"], 
                                info["port"], 
                                info["name"], 
                                info["family"], 
                                info["type"],
                                random
                                
                            )
                        del bind_cache[pid]
                    
                # Search for fork patterns on PIDs with open ports
                match = re.search(fork_pattern, line)
                if match:
                    # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Clone Flags | 5 - Stack Size
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    if pid in process_activity.keys():
                        if not process_activity[pid]:
                            self.reportStruct.port_activity.new_fork()

                # Search for fork return patterns to assign activity
                match = re.search(fork_ret_pattern, line)
                if match:
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    child_pid = int(match.group(4))
                    self.reportStruct.port_activity.inherit_from_fork(pid, child_pid)

                # Search for close syscalls on file descriptors that we care about
                match = re.search(close_pattern, line)
                if match:
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    fd = int(match.group(4))
                    self.reportStruct.port_activity.new_close(timestamp, pid, fd)

                # Search for exit systemcalls
                match = re.search(exit_pattern, line)
                if match:
                    # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - Return code
                    timestamp = float(match.group(1))
                    pid = int(match.group(2))
                    self.reportStruct.port_activity.new_exit(timestamp, pid)

        self.reportStruct.port_activity.end()

        for port in self.reportStruct.port_activity.port_history.keys():
            item = self.reportStruct.port_activity.port_history[port]
            print(f"[Port {port}]")
            for instance in item["instances"]:
                if (instance["random"] == True):
                    print(f"|-[Instance] (Randomly Assigned Port)")
                else:
                    print(f"|-[Instance]")
                print(f"| |- Owner: {instance["owner"][0]}({instance["owner"][1]})]")
                print(f"| |- Access: {instance["access_history"]}]")
                print(f"| |- Family: {instance["family"]} - Type: {instance["type"]}]")
                print(f"| |- Timestamps: {instance["times"][0]} - {instance["times"][1]}]")
                    
        # Decompress the file system for analysis
        cache_dir = os.path.join(self.reportStruct.report_path, "fs")
        os.makedirs(cache_dir, exist_ok=True)

        with tarfile.open(self.reportStruct.filesystem_path, "r:gz") as tar:
            tar.extractall(path=cache_dir)

        log.message("info", "Fixing Symlinks in the report folder.", "FirmAE")

        links = 0
        fixed = 0

        for dirpath, dirnames, filenames in os.walk(cache_dir):
            for name in dirnames + filenames:
                path = os.path.join(dirpath, name)

                if os.path.islink(path) and not os.path.exists(path):
                    links += 1
                    target = os.readlink(path)
                    
                    # Attempt to fix the path
                    new_target = os.path.join(cache_dir, target.lstrip("/"))
                    
                    if os.path.exists(new_target):
                        os.remove(path)
                        os.symlink(new_target, path)
                        fixed += 1

        log.message("warn", f"{fixed}/{links} Symlinks were successfully fixed", "FirmAE")

        # Retrive all execv calls from critical PIDS
        log.message("info", "Associating Ports to executables.", "FirmAE")

        # Pattern for retriving execve argument values:
        # 1 - Timestamp | 2 - PID | 3 - Process Name | 4 - argv | 5 - env
        # execve_pattern = r"\[\s*(\d+\.\d+)]\s+firmadyne:\s+do_execve\[PID:\s*(\d+)\s+\(([^)]+)\)]:\s+argv:\s*\[\s*([^\]]+?)\s*],\s*envp:\s*PATH=([^ ]+)\s+HOME=([^ ]+)\s+SHELL=([^\s]+)"
        execve_pattern = r"\[\s*(\d+\.\d+)]\s+firmadyne:\s+do_execve\[PID:\s*(\d+)\s+\(([^)]+)\)]:\s+argv:\s*([^\]]+?),\s*envp:\s*(.+)"

        print(f"Pid matched: {self.reportStruct.port_activity.critical_processes}")
        pid_to_binary = {}
        critical_binaries = {}
        with open(input_file, 'r', errors='ignore') as file:

            for line in file:

                # Search for execve systemcalls
                match = re.search(execve_pattern, line)
                if match:
                    pid = int(match.group(2))
                    if pid in self.reportStruct.port_activity.critical_processes:
                        # print(f"Pid matched: {pid}")
                        timestamp = float(match.group(1))
                        proc_name = match.group(3)
                        argv = match.group(4)
                        env = match.group(5)
                        env_vars = dict(kv.split("=", 1) for kv in env.split() if "=" in kv)

                        home = env_vars.get("HOME", "")
                        path = env_vars.get("PATH", "")
                        shell = env_vars.get("SHELL", "")
                        

                        argv_list = shlex.split(argv)
                        path_list = path.split(':')
                        # print(argv_list)

                        cmd = argv_list[0]
                        possible_locations = []


                        if cmd == "sh":
                            # Find the bash script
                            for arg in argv_list:
                                if arg != "sh" and arg[0] != '-':
                                    cmd = arg
                                    break

                        # Absolute path call - Assign to the path directly
                        if cmd[0] == "/":
                            cmd = argv_list[0].lstrip("/")
                            target_binary = os.path.join(cache_dir, cmd)
                            possible_locations.append(target_binary)

                        # Create a possible path for each item inside of the $PATH
                        for p in path_list:
                            folder = p.lstrip("/")
                            target_binary = os.path.join(cache_dir, folder, cmd)
                            possible_locations.append(target_binary)

                        # Check if this file exists or not
                        item = None
                        for target in possible_locations:
                            if os.path.isfile(target):
                                item = (timestamp, target, argv)
                                # print(f"Found binary file at: {target}")
                                break
                        
                        # If it doesn't exist just add it as unknown path
                        if item is None:
                            # log.message("warn", "No binary found")
                            item = (timestamp, "Unknown", argv)
                        
                        if pid not in pid_to_binary.keys():
                            pid_to_binary[pid] = [item]
                        else:
                            exists = False
                            for other in pid_to_binary[pid]:
                                if item[1] == other[1] and item[2] == other[2]:
                                    exists = True
                                    break
                            if not exists:
                                pid_to_binary[pid].append(item)
                        
                        if item[1] != "Unknown":
                            if item[1] not in critical_binaries.keys():
                                critical_binaries[item[1]] = {"pids": set(),
                                                             "owns": set(),
                                                             "access": set(),
                                                             "CVEs": []}
                            critical_binaries[item[1]]["pids"].add(pid)

        # print(critical_binaries)

        # for pid in pid_to_binary.keys():
        #     print(f"PID: {pid} | {pid_to_binary[pid]}")
        
        self.reportStruct.port_activity.binary_report = critical_binaries

        CveLookup.run_grype_on_directory(self.reportStruct)

        shutil.copy(input_file, os.path.join(self.reportStruct.report_path, "systemcalls.log"))

        # Perform process profiling for all critical processes
        for binary in self.reportStruct.port_activity.binary_report.keys():
            # Find all ports that can me accessed by this binary
            ports = set()
            owns = set()
            for pid in self.reportStruct.port_activity.binary_report[binary]["pids"]:
                for port in self.reportStruct.port_activity.pid_to_ports[pid]["access"]:
                    ports.add(port)
                for port in self.reportStruct.port_activity.pid_to_ports[pid]["owns"]:
                    owns.add(port)
            self.reportStruct.port_activity.binary_report[binary]["access"] = ports 
            self.reportStruct.port_activity.binary_report[binary]["owns"] = owns
            self.reportStruct.port_activity.binary_report[binary]["label"] = self.binary_profiling(binary, "", list(ports))
            self.reportStruct.port_activity.binary_report[binary]["label"].print()

        for binary in self.reportStruct.port_activity.binary_report.keys():
           self.reportStruct.port_activity.binary_report[binary]["label"].print()
           CveLookup.print_cve(self.reportStruct.port_activity.binary_report[binary]["CVEs"])
        
        return
        
    def check(self):
        command = ["sudo", "-E", "./run.sh", "-c", self.reportStruct.brand, os.path.abspath(self.reportStruct.firware_path)]
        try:
            log.message("info", "Elavated permissions are required, enter sudo password if prompted", "FirmAE")
            result = subprocess.run(command, cwd=self.PATH_TO_FIRMAE, text=True, check=True)
        except subprocess.CalledProcessError as e:
            return f"Error: {e.stderr}"
        
        db = self.connect_to_db()
        if db:
            with db.cursor() as cur:
                cur.execute("SELECT id FROM image WHERE hash=%s;", (str(self.reportStruct.md5_hash),))
                result = cur.fetchone()
                if result is not None:
                    image_id = result[0]
                    self.reportStruct.filesystem_path = self.PATH_TO_FIRMAE + "images/" + str(image_id) + ".tar.gz"
                    self.reportStruct.logs = self.PATH_TO_FIRMAE + "scratch/" + str(image_id) + "/"
                else:
                    log.message("error", "FirmAE failed miserably.", "FirmAE")
                    self.reportStruct.result = "Failed"
            db.close()

        self.analysis()
        return
        
    def emulate(self):

        def check_ready(process, target, result_flag):
            for line in process.stdout:
                print(line)
                if target in line:
                    result_flag['running'] = True
                    break
                if "RTNETLINK answers: File exists" in line:
                    log.message("warn", f"Tap Device setup failed, (tap1_0 already exists)", "FirmAE -run")
                    self.result = "Failed"
                    break

        command = ["sudo", "-E", "./run.sh", "--run", self.reportStruct.brand, os.path.abspath(self.reportStruct.firware_path)]
        # Start the process
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            cwd=self.PATH_TO_FIRMAE,
            text=True,
            bufsize=1
        )

        target_text = self.reportStruct.ip_address + " true true"
        result = {'running': False}

        # Start a thread to read output
        reader_thread = threading.Thread(target=check_ready, args=(process, target_text, result))
        reader_thread.start()

        timeout_seconds = 900
        reader_thread.join(timeout_seconds)

        if reader_thread.is_alive():
            log.message("warn", f"Emulation Timeout reached ({timeout_seconds} s). Firmware emulation exiting...")
            self.reportStruct.result = "Failed"
            process.terminate()
            reader_thread.join()

        if result['running']:
            log.message("info", f"Firmware emulation open at IP {self.reportStruct.ip_address}.", "FirmAE -run")
        else:
            self.reportStruct.result = "Failed"
            log.message("error", f"Firmware emulation failed.", "FirmAE -run")

        self.emulationProc = process
        return

    def terminate(self):
        
        if self.emulationProc.poll() is not None:
            log.message("warn", f"Emulation exited unexpectedly with return code {self.emulationProc.returncode}")
        else:
            os.kill(self.emulationProc.pid, signal.SIGINT)
            try:
                self.emulationProc.wait(timeout=20)
                log.message("info", f"Firmware emulation exited cleanly.", "FirmAE -run")
            except subprocess.TimeoutExpired:
                print("warn", "Firmware emulation did not exit peacefully, proccess forced killed." "FirmAE -run")
                self.emulationProc.kill()
        return


    def clean_up(self):
        """
        Removes cache files genarated by the emulation engine. This DOES NOT include the reports generated by RePort itself.
        """

        # Clear the database #
        db = self.connect_to_db()
        if db:
            with db.cursor() as cur:
                try:
                    cur.execute("TRUNCATE TABLE brand, image, object, object_to_image, product RESTART IDENTITY CASCADE;")
                    log.message("info", "Database tables truncated successfully.", "FirmAE")
                except Exception as e:
                    log.message("error", f"Failed to truncate data base tables: {e}", "FirmAE")
            db.close()

        # Scratch and Image Folders to reset #
        scratch_dir = os.path.join(self.PATH_TO_FIRMAE, "scratch")
        images_dir = os.path.join(self.PATH_TO_FIRMAE, "images")

        for directory in [scratch_dir, images_dir]:
            try:
                # Delete the folders
                if os.path.exists(directory):
                    shutil.rmtree(directory)
                # Create new empty ones
                os.makedirs(directory, exist_ok=True)
            except Exception as e:
                log.message("error", f"Failed to reset {directory}: {e}", "FirmAE")

        # Network Clean Up
        self.network_fix()
        
        return

    def network_fix(self):
        """
        Removes the tap1_0 device, which gets generated by FirmAE
        """

        # Network Clean Up
        try:
            command = ["sudo", "ip", "link", "delete", "tap1_0"]
            result = subprocess.run(command, cwd=self.PATH_TO_FIRMAE, text=True, check=True)
            log.message("info", "TAP device removed succesfully.", "FirmAE")
        except subprocess.CalledProcessError as e:
            log.message("info", "TAP device did not exist.", "FirmAE")
        
        return

    
    def result_output(self):

        for port in self.reportStruct.port_activity.port_history.keys():
            item = self.reportStruct.port_activity.port_history[port]
            output = f"[Port {port}]\n"
            for instance in item["instances"]:
                if (instance["random"]):
                    output += f"|-[Instance] (Randomly Assigned Port)\n"
                else:
                    output += f"|-[Instance]\n"
                output += f"| |- Owner: {instance["owner"][0]}({instance["owner"][1]})]\n"
                output += f"| |- Access: {instance["access_history"]}]\n"
                output += f"| |- Timestamps: {instance["times"][0]} - {instance["times"][1]}]\n"
            if item["verification"] is not None:
                output += f"|-(Verified)\n="
            else:
                output += f"|-(Not Verified)\n="
            log.output(output)

        # for port in self.reportStruct.ports.keys():
        #     output = f"[Port {port}]\n" + f"|-(Possible Owner)\n" 
        #     for own in self.reportStruct.ports[port]["owners"]:
        #         output += self.reportStruct.critical_processes[own].owner_print()
        #     if len(self.reportStruct.ports[port]["verification"]) != 0:
        #         output += f"-- Verified\n="
        #     else:
        #         output += f"-- Not Verified\n="
        #     log.output(output)

if __name__ == "__main__":
    # firmware_path = "/home/dimitris/Documents/thesis/FirmAE/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip"
    firmware_path = "/home/porichis/dit-thesis/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip"
    engine = FirmAE(firmware=firmware_path)
    
    engine.install()
    # engine.check()